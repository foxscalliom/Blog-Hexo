{"meta":{"title":"百里の博客","subtitle":"倘只看书,便变成书橱","description":"我好像一只牛,吃的是草,挤出的是牛奶","author":"百里","url":"https://i100.xyz","root":"/"},"pages":[{"title":"tags","date":"2022-01-08T05:50:54.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"tags/index.html","permalink":"https://i100.xyz/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-01-08T05:51:34.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"categories/index.html","permalink":"https://i100.xyz/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"如何让你的代码更优雅","slug":"如何让你的代码更优雅","date":"2022-01-08T08:35:04.000Z","updated":"2022-01-09T09:36:55.915Z","comments":true,"path":"posts/932a8af7.html","link":"","permalink":"https://i100.xyz/posts/932a8af7.html","excerpt":"常量赋值引用数据类型包括接口中返回的数据，要做好兜底 12let lastName = fullName[1] || &#x27;&#x27;let propertyValue=Object.attr || 0 指明类型要按强类型风格写代码定义变量的时候要指明类型，并且在变量声明之后，不要随意的去更改变量的数据类型 123// 假设声明三个变量a,b,clet a,b,c; // difference，定义变量时没有指明类型let a = &quot;&quot;, b = [], c = &#123;&#125;; // good 逻辑判断==逻辑判断注意== 表示只要值相等即为真，=== 要求不仅值相等，而且也要求类型相同使用== 有时候会达不到预期的结果，埋下隐患 123456789100 == &#x27;&#x27; // true0 == &#x27;0&#x27; // true&#x27;&#x27; == 0 // true&#x27;&#x27; == &#x27;0&#x27; // falsefalse == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == undefined // falsefalse == null // falsenull == undefined // truetrue == 1 // true 数据类型不确定如果变量的数据类型不确定，那咱就手动的转换一下，让它确定 12let total = &quot;6&quot;;if(parseInt(total) === 6)&#123;&#125; // grace 手动转换一下数据类型","text":"常量赋值引用数据类型包括接口中返回的数据，要做好兜底 12let lastName = fullName[1] || &#x27;&#x27;let propertyValue=Object.attr || 0 指明类型要按强类型风格写代码定义变量的时候要指明类型，并且在变量声明之后，不要随意的去更改变量的数据类型 123// 假设声明三个变量a,b,clet a,b,c; // difference，定义变量时没有指明类型let a = &quot;&quot;, b = [], c = &#123;&#125;; // good 逻辑判断==逻辑判断注意== 表示只要值相等即为真，=== 要求不仅值相等，而且也要求类型相同使用== 有时候会达不到预期的结果，埋下隐患 123456789100 == &#x27;&#x27; // true0 == &#x27;0&#x27; // true&#x27;&#x27; == 0 // true&#x27;&#x27; == &#x27;0&#x27; // falsefalse == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == undefined // falsefalse == null // falsenull == undefined // truetrue == 1 // true 数据类型不确定如果变量的数据类型不确定，那咱就手动的转换一下，让它确定 12let total = &quot;6&quot;;if(parseInt(total) === 6)&#123;&#125; // grace 手动转换一下数据类型 数组数组拷贝12345let items=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;];const itemCopy = [...items]// joining arrays const odd = [1, 3, 5 ]; const nums = [2 ,4 , 6, ...odd]; 变量赋值12const Arr = [1, 2, 3, 4];const [first, second] = Arr; 函数的命名 返回布尔值函数应以is/can/has等单词开头，能够让人更直观的了解到这个函数的功能；获取接口中的数据使用get开头进行命名,动作函数要以动词开头。 12345// gracelet isSupport = () =&gt; &#123;&#125;;let canUpdate = () =&gt; &#123;&#125;;let geUserInfo = (user) =&gt; &#123;&#125;let setUserInfo = (user) =&gt; &#123;&#125; 优先使用箭头函数12// grace 是不是看着更简介优雅了let findAge = (arr, age)=&gt; arr.filter(num =&gt; num === age) 函数的入参函数的入参，是能够让使用者，在调用这个函数的时候，能够更加的清晰明了的把这个函数所需要的参数传递给函数，不容易出现，参数传递错误（参数的顺序颠倒等）一些低级，而又不好查找的问题 12345678910// difference// true和false啥意思，没有个注释的话，看上去就是一脸懵逼function getImages(api, true, false); // grace// 一目了然，知道这些true和false是啥意思function getImages(&#123; imageApi: api, includePageBackground: true, compress: false,&#125;) 接收参数如果函数的的参数是对象，也要优先使用解构赋值，上代码 12345678910111213141516171819202122232425// 假设现在的场景是获取用户的信息上的现用名，和曾用名// differencefunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// commonlyfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// gracefunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125;// grace 给它个默认值function getFullName(&#123;firstName, lastName = &#x27;无&#x27;&#125;) &#123;&#125; // 觉得参数的名称太长，咱再来个重命名 解构时重命名简化命名// gracefunction getFullName (&#123;firstName: first, lastName: last&#125;) &#123; &#125; 参数效验更少的嵌套，不满足条件尽早 return，尽可能的减少嵌套，嵌套的层级越少，函数看着越简洁优雅 123456function test(name, sex = 1) &#123; // 不满足条件尽早抛出错误 if (!name)&#123; throw new Error(&#x27;没有传递name参数&#x27;); &#125;&#125; 函数的出参对象作为返回值，更便于以后添加返回值，以及更改返回值的顺序，相对于数组更加的灵活，更便于扩展 1234567891011// 函数返回多个值，推荐使用对象作为函数的返回值// commonlyfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// gracefunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 立即执行函数立即执行函数也推荐写成箭头函数的形式。首先是因为更简洁，并且也绑定好 this（箭头函数不会去改变this的指向）。 123(() =&gt; &#123; console.log(&#x27;立即执行函数&#x27;);&#125;)(); 优先使用函数式编程123456// differencefor(i = 1; i &lt;= 10; i++) &#123; a[i] = a[i] +1;&#125;// gracelet b = a.map(item =&gt; ++item) //是不是更简洁了 函数中过多的采用if else12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// commonlyif (a === 1) &#123; //...&#125; else if (a ===2) &#123; // ...&#125; else if (a === 3) &#123; //...&#125; else &#123; //...&#125; // 一般switch(a) &#123; case 1: //.... case 2: //.... case 3: //.... default: //....&#125;// grace ===》》》 Objectconst fruit = &#123; 1: [&#x27;1&#x27;, &#x27;11&#x27;], 2: [&#x27;2&#x27;, &#x27;22&#x27;], 3: [&#x27;3&#x27;, &#x27;33&#x27;] &#125;;let test = (a) =&gt; &#123; return fruit[a] || [];&#125;// grace ===》》》 Mapconst fruit = newMap() .set(&#x27;张三&#x27;, [&#x27;张三丰&#x27;, &#x27;张三力&#x27;]) .set(&#x27;李四&#x27;, [&#x27;李思维&#x27;, &#x27;李素丽&#x27;])let test = (a) =&gt; &#123; return fruit.get(a) || [];&#125;// grace ===》》》filterconst fruits = [ &#123; name: &#x27;张三&#x27;, work: &#x27;js&#x27; &#125;, &#123; name: &#x27;李四&#x27;, work: &#x27;php&#x27; &#125;, &#123; name: &#x27;王五&#x27;, work: &#x27;java&#x27; &#125;, ];let test = (a) =&gt; &#123; return fruits.filter(item =&gt; item.name === a);&#125;// grace===》》》策略模式let handler = &#123; 1: () =&gt; &#123; //.... &#125;, 2: () =&gt; &#123; //.... &#125;, 3: () =&gt; &#123; //.... &#125;, default: () =&gt; &#123; //.... &#125;&#125;handler[a]() || handler[&#x27;default&#x27;]() 温馨小提示一个函数完成一个独立的功能，不要一个函数混杂多个功能，在项目开发中有一条非常重要的原则【单一原则】所谓的单一原则就是，一个函数（文件），只做一件事情，在开发当中，没有那个项目是开发完成之后，就结束了。需要不断的更新，维护，那么单一原则，就是为了方便开发，和维护的，不要让一个函数“又当爹，又当妈”，这样代码的耦合性太高了，不好维护 其他判断数组长度1234567891011121314151617181920// differenceif (arr.length !== 0) &#123; //...&#125;// graceif (arr.length) &#123; //...&#125;// differenceif (arr.length === 0) &#123; //...&#125;// graceif (!arr.length) &#123; //...&#125; 逻辑运算符12345678910111213141516171819202122if (a === 1) &#123; b()&#125;//可以写成a === 1 &amp;&amp; b()const arr = [1,2,3];if(!arr.length)&#123; b() &#125;//可以写出arr.length || b()// &amp;&amp;判断依赖的键是否存在，防止报错&#x27;xxx of undfined&#x27;let user = &#123; name: &#x27;Symbol卢&#x27;, age: 18, children: &#123; name: &#x27;小Symbol卢&#x27; &#125;&#125;let childrenName = user.children &amp;&amp; user.childre.name 三目运算符1234567891011// differenceconst a = &#x27;&#x27;;let b;if( a === &#x27;&#x27; )&#123; b = &#x27;no&#x27;&#125; else &#123; b = &#x27;ok&#x27;&#125;const a = &#x27;&#x27;let b = a ? &#x27;no&#x27; : &#x27;ok&#x27;; // &#x27;ok&#x27; 函数定义12345678/** * @description: 数据类型的检测的第二种方式 * @param &#123;any&#125; data 要检测数据类型的变量 * @return &#123;string&#125; type 返回具体的类型名称【小写】 */export const isTypeOf = (data) =&gt; &#123; return Object.prototype.toString.call(data).replace(/\\[object (\\w+)\\]/, &#x27;$1&#x27;).toLowerCase()&#125; 使用 Array.includes 来处理多重 || 条件123456789// differenceif (a === 1 || a === 2 || a === 3 || a === 4) &#123; //...&#125;// gracelet arr = [1, 2, 3, 4]if (arr.includes(a)) &#123; //...&#125; 使用 Array.every 和 Array.some 来处理全部/部分满足条件123456789101112// graceconst users = [ &#123; name: &#x27;张三&#x27;, sex:1 &#125;, &#123; name: &#x27;李四&#x27;, sex:2 &#125;, &#123; name: &#x27;王五&#x27;, sex:1 &#125; ];function test() &#123; // 条件：（简短形式）所有的用户都必须是女 const isAllGirl = users.every(item =&gt; item.sex === 1); // 条件：至少一个用户是男的 const isAnyMan = users.some(item =&gt; item.sex === 2);&#125; 使用正则表达式12345678const imgType =&#x27;jpg&#x27;if(imgType === &#x27;jpg&#x27; || imgType === &#x27;png&#x27; || imgType === &#x27;gif&#x27;)&#123; console.log(&#x27;is image&#x27;)&#125;// 使用match匹配正则表达式if(imgType.match(/.*?(gif|png|jpg)/gi))&#123; console.log(&#x27;is image&#x27;)&#125; 连接字符串1234let name = &#x27;Symbol&#x27;let message = &#x27;Hello,I\\&#x27;m&#x27; + name + &#x27;take care &#x27;// 采用传统加号，看着很冗余,且容易出错// 艾玛，模板字符香，真想let message = `Hello,I&#x27;m $&#123;name&#125; take care `","categories":[{"name":"前端","slug":"前端","permalink":"https://i100.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"优雅","slug":"优雅","permalink":"https://i100.xyz/tags/%E4%BC%98%E9%9B%85/"}]},{"title":"git常用命令总结","slug":"git常用命令总结","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/acc3d3b0.html","link":"","permalink":"https://i100.xyz/posts/acc3d3b0.html","excerpt":"新建仓库1234567echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:foxscalliom/test.gitgit push -u origin main","text":"新建仓库1234567echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:foxscalliom/test.gitgit push -u origin main 拉取仓库123git remote add origin git@github.com:foxscalliom/test.gitgit branch -M maingit push -u origin main 不保留本地12git reset --hard git pull origin main","categories":[{"name":"Git","slug":"Git","permalink":"https://i100.xyz/categories/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"https://i100.xyz/tags/github/"}]},{"title":"在centos7安装nodejs并升级nodejs版本","slug":"在centos7安装nodejs并升级nodejs版本","date":"2022-01-06T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/59268fdb.html","link":"","permalink":"https://i100.xyz/posts/59268fdb.html","excerpt":"1. 安装 nodejs 1.1 使用 EPEL 安装EPEL（Extra Packages for Enterprise Linux）企业版 Linux 的额外软件包，是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。先确认系统是否已经安装了 epel-release 包： 12$ yum info epel-release","text":"1. 安装 nodejs 1.1 使用 EPEL 安装EPEL（Extra Packages for Enterprise Linux）企业版 Linux 的额外软件包，是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。先确认系统是否已经安装了 epel-release 包： 12$ yum info epel-release 如果有输出有关 epel-release 的已安装信息，则说明已经安装，如果提示没有安装或可安装，则安装 1$ yum install epel-release 安装完后，就可以使用 yum 命令安装 nodejs 了，安装的一般会是 6.x 的版本，并且会将 npm(3.x) 作为依赖包一起安装 1$ sudo yum install nodejs 安装完成后，验证是否正确的安装，node -v，如果输出如下版本信息，说明成功安装 1v6.13.3 问题来了，现在 nodejs 发的版本比较快，有些新的框架需要 node 的新版本，那如何升级。到现在，node 的最新版本是10.4.1，那么，下面介绍如何升级 nodejs 1.2 卸载 nodejs 注意：这里卸载并非必要步骤。只是提供卸载的方案，请按需操作，不要安装后又删除又进行安装掉进死循环了。 1.2.1 使用 yum 先删除一次 1yum remove nodejs npm -y 1.2.2 手动删除残留 进入 /usr/local/lib 删除所有 node 和 node_modules 文件夹 进入 /usr/local/include 删除所有 node 和 node_modules 文件夹 检查 ~ 文件夹里面的 “local” “lib” “include” 文件夹，然后删除里面的所有 “node” 和 “node_modules” 文件夹 可以使用以下命令查找 $ find ~/ -name node $ find ~/ -name node_modules 1.2.3 进入 /usr/local/bin 删除 node 的可执行文件 删除: /usr/local/bin/npm 删除: /usr/local/share/man/man1/node.1 删除: /usr/local/lib/dtrace/node.d 删除: rm -rf /home/[homedir]/.npm 删除: rm -rf /home/root/.npm 2. 升级 nodesj 2.1 安装 nn 是 nodejs 管理工具，是 TJ 写的，Github: https://github.com/tj/n 1$ npm install -g n 2.2 安装 nodejs 版本安装最新版 1$ n latest 安装指定版本 1$ n 8.11.3 2.3 切换 nodejs 版本1$ n 选择已安装的版本 12node/8.11.3node/10.4.1 查看当前版本node -v，下面表示已切换成功 1v8.13.3 但问题来了，切换后，查看版本还是原来的 v6.13.3，看下面 使用 n 切换 nodejs 版本失效的解决办法 3 切换失效的解决办法 3.1 查看 node 当前安装路径12$ which node/usr/local/bin/node #举个例子 3.2 修改默认路径而 n 默认安装路径是 /usr/local，若你的 node 不是在此路径下，n 切换版本就不能把 bin、lib、include、share 复制该路径中，所以我们必须通过 N_PREFIX 变量来修改 n 的默认 node 安装路径。编辑环境配置文件： 1$ vim ~/.bash_profile 3.3 将下面两行代码插入到文件末尾：12export N_PREFIX=/usr/local #node实际安装位置export PATH=$N_PREFIX/bin:$PATH 3.4 :wq保存退出3.5 执行 source 使修改生效。1$ source ~/.bash_profile 3.6 这时候再查看node -v发现版本切换成功了。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://i100.xyz/posts/4a17b156.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://i100.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Git","slug":"Git","permalink":"https://i100.xyz/categories/Git/"}],"tags":[{"name":"优雅","slug":"优雅","permalink":"https://i100.xyz/tags/%E4%BC%98%E9%9B%85/"},{"name":"github","slug":"github","permalink":"https://i100.xyz/tags/github/"}]}