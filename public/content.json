{"meta":{"title":"百里の博客","subtitle":"倘只看书,便变成书橱","description":"我好像一只牛,吃的是草,挤出的是牛奶","author":"百里","url":"https://www.i100.xyz","root":"/"},"pages":[{"title":"categories","date":"2022-01-08T05:51:34.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"categories/index.html","permalink":"https://www.i100.xyz/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-01-08T05:50:54.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"tags/index.html","permalink":"https://www.i100.xyz/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"压力测试接口文档","slug":"压力测试接口文档","date":"2022-01-12T09:38:22.000Z","updated":"2022-01-12T13:58:53.790Z","comments":true,"path":"posts/2a8cc5d6.html","link":"","permalink":"https://www.i100.xyz/posts/2a8cc5d6.html","excerpt":"项目规划列表接口：/qydzh/modules/project 请求方式：get 请求参数 123456789pageNo: 1pageSize: 15order: desccolumn: createTimename: startDate_begin: startDate_end: endDate_begin: endDate_end:","text":"项目规划列表接口：/qydzh/modules/project 请求方式：get 请求参数 123456789pageNo: 1pageSize: 15order: desccolumn: createTimename: startDate_begin: startDate_end: endDate_begin: endDate_end: 删除接口：/modules/project/del 请求方式：get 请求参数 1id: 编辑接口：/modules/project/ 请求方式：put 请求参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; &quot;id&quot;: &quot;1480737729881718785&quot;, &quot;projectType&quot;: &quot;2&quot;, &quot;name&quot;: &quot;测试项目10011&quot;, &quot;constructId&quot;: &quot;88eefdf9aa5243e7847df51fdb66275a&quot;, &quot;parkingArea&quot;: null, &quot;surveyId&quot;: &quot;a3902898c45c40da9c1443221e597efd&quot;, &quot;endDate&quot;: &quot;2022-01-22&quot;, &quot;landPermitNum&quot;: null, &quot;surveyUserId&quot;: null, &quot;seismicGrade&quot;: null, &quot;developmentId&quot;: &quot;124a98694e2c4434a83a146871023588&quot;, &quot;integrity&quot;: null, &quot;trialUserId&quot;: null, &quot;progressStatus&quot;: null, &quot;inspectUserId&quot;: null, &quot;height&quot;: null, &quot;developmentId_dictText&quot;: &quot;某某建设单位&quot;, &quot;buildUpArea&quot;: null, &quot;projectType_dictText&quot;: &quot;市政基础设施工程&quot;, &quot;landPlanPermitNum&quot;: null, &quot;constructNum&quot;: null, &quot;startPoint&quot;: null, &quot;directorUserId&quot;: null, &quot;totalLength&quot;: 10, &quot;version&quot;: 1, &quot;developmentUserId&quot;: null, &quot;basicType&quot;: null, &quot;areaCode&quot;: &quot;350602&quot;, &quot;measureUserId&quot;: null, &quot;coverAnArea&quot;: &quot;1000&quot;, &quot;technologyUserId&quot;: null, &quot;sysOrgCode&quot;: &quot;A43&quot;, &quot;totalCost&quot;: 100, &quot;startDate&quot;: &quot;2022-01-05&quot;, &quot;progressStatus_dictText&quot;: null, &quot;scale&quot;: null, &quot;delFlag&quot;: &quot;0&quot;, &quot;manageUserId&quot;: null, &quot;constructUserId&quot;: null, &quot;updateBy&quot;: &quot;admin&quot;, &quot;serviceLife&quot;: null, &quot;sysOrgCode_dictText&quot;: &quot;漳州市质量安全监督站&quot;, &quot;ratifyId&quot;: &quot;&quot;, &quot;designUserId&quot;: null, &quot;supervisionId&quot;: &quot;9d2cfda3ddd14946a0bb747090b4b40a&quot;, &quot;address&quot;: &quot;测试&quot;, &quot;supervisionUserId&quot;: null, &quot;updateTime&quot;: &quot;2022-01-12 09:48:20&quot;, &quot;isSubmit&quot;: &quot;0&quot;, &quot;ratifyNum&quot;: null, &quot;parkingAmount&quot;: null, &quot;endPoint&quot;: null, &quot;createBy&quot;: &quot;admin&quot;, &quot;createTime&quot;: &quot;2022-01-11 11:06:00&quot;, &quot;structureType&quot;: null, &quot;designId&quot;: &quot;f1d96846542844d097e008a7ad5987fe&quot;, &quot;planPermitNum&quot;: null, &quot;buildingsAmount&quot;: null, &quot;secureUserId&quot;: null, &quot;theSizeOfThe&quot;: &quot;10m&quot;&#125; 添加接口：/modules/project/ 请求方式：post 请求参数 12345678910111213141516171819202122232425262728&#123; &quot;areaCode&quot;: &quot;350600&quot;, &quot;projectType&quot;: &quot;1&quot;, &quot;name&quot;: &quot;测试&quot;, &quot;address&quot;: &quot;三星村&quot;, &quot;startDate&quot;: &quot;2022-01-12T02:24:15.226Z&quot;, &quot;endDate&quot;: &quot;2022-01-12T02:25:30.863Z&quot;, &quot;coverAnArea&quot;: &quot;1&quot;, &quot;buildUpArea&quot;: &quot;1&quot;, &quot;parkingArea&quot;: null, &quot;parkingAmount&quot;: null, &quot;totalCost&quot;: &quot;1&quot;, &quot;buildingsAmount&quot;: &quot;1&quot;, &quot;serviceLife&quot;: null, &quot;seismicGrade&quot;: null, &quot;developmentId&quot;: &quot;124a98694e2c4434a83a146871023588&quot;, &quot;ratifyId&quot;: &quot;&quot;, &quot;designId&quot;: &quot;f1d96846542844d097e008a7ad5987fe&quot;, &quot;surveyId&quot;: &quot;a3902898c45c40da9c1443221e597efd&quot;, &quot;supervisionId&quot;: &quot;9d2cfda3ddd14946a0bb747090b4b40a&quot;, &quot;constructId&quot;: &quot;88eefdf9aa5243e7847df51fdb66275a&quot;, &quot;ratifyNum&quot;: null, &quot;planPermitNum&quot;: null, &quot;landPlanPermitNum&quot;: null, &quot;landPermitNum&quot;: null, &quot;constructNum&quot;: null, &quot;totalLength&quot;: null&#125; 单位工程工程查询接口：/qydzh/modules/unitProject 请求方式：get 请求参数 1projectId: 工程添加接口：/qydzh/modules/unitProject 请求方式：post 请求参数 1234567891011121314151617181920212223&#123; &quot;span&quot;: null, &quot;projectId&quot;: &quot;1481091682054127618&quot;, &quot;name&quot;: &quot;漳州市瑞京西路（西院湖）连心桥项目&quot;, &quot;unitType&quot;: &quot;2&quot;, &quot;structureType&quot;: &quot;8&quot;, &quot;designId&quot;: &quot;f1d96846542844d097e008a7ad5987fe&quot;, &quot;cost&quot;: &quot;100&quot;, &quot;buildUpArea&quot;: null, &quot;surveyId&quot;: &quot;a3902898c45c40da9c1443221e597efd&quot;, &quot;height&quot;: null, &quot;liftNum&quot;: null, &quot;supervisionId&quot;: &quot;9d2cfda3ddd14946a0bb747090b4b40a&quot;, &quot;constructId&quot;: &quot;88eefdf9aa5243e7847df51fdb66275a&quot;, &quot;aboveGroundNum&quot;: null, &quot;underGroundNum&quot;: null, &quot;startDate&quot;: &quot;&quot;, &quot;endDate&quot;: &quot;&quot;, &quot;length&quot;: &quot;100&quot;, &quot;width&quot;: &quot;100&quot;, &quot;unitType_dictText&quot;: &quot;市政基础设施工程&quot;, &quot;developmentId&quot;: &quot;124a98694e2c4434a83a146871023588&quot;&#125; 添加专业接口：/qydzh/modules/unitMajorRel 请求方式：post 请求参数 1234567&#123; &quot;unitProjectId&quot;: &quot;1481092100704387074&quot;, &quot;arrMajorId&quot;: [ &quot;1448121297935400962&quot;, &quot;1446650928816926722&quot; ]&#125; 工程编辑接口：/qydzh/modules/unitProject 请求方式：put 请求参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&#123; &quot;constructId&quot;: &quot;88eefdf9aa5243e7847df51fdb66275a&quot;, &quot;mapNum&quot;: null, &quot;surveyId&quot;: &quot;a3902898c45c40da9c1443221e597efd&quot;, &quot;endDate&quot;: &quot;&quot;, &quot;num&quot;: null, &quot;surveyUserId&quot;: null, &quot;spec&quot;: null, &quot;developmentId&quot;: &quot;124a98694e2c4434a83a146871023588&quot;, &quot;trialUserId&quot;: null, &quot;id&quot;: &quot;1481092100704387074&quot;, &quot;inspectUserId&quot;: null, &quot;height&quot;: null, &quot;developmentId_dictText&quot;: &quot;某某建设单位&quot;, &quot;buildUpArea&quot;: null, &quot;level&quot;: null, &quot;startPoint&quot;: null, &quot;projectId_dictText&quot;: &quot;嘤嘤嘤&quot;, &quot;directorUserId&quot;: null, &quot;version&quot;: 1, &quot;developmentUserId&quot;: null, &quot;basicType&quot;: null, &quot;areaCode&quot;: &quot;350600&quot;, &quot;measureUserId&quot;: null, &quot;holeNum&quot;: null, &quot;name&quot;: &quot;漳州市瑞京西路（西院湖）连心桥项目&quot;, &quot;technologyUserId&quot;: null, &quot;sysOrgCode&quot;: &quot;A43&quot;, &quot;startDate&quot;: &quot;&quot;, &quot;scale&quot;: null, &quot;unitProjectLoad&quot;: null, &quot;unitType_dictText&quot;: &quot;市政基础设施工程&quot;, &quot;delFlag&quot;: &quot;0&quot;, &quot;manageUserId&quot;: null, &quot;constructUserId&quot;: null, &quot;unitType&quot;: &quot;2&quot;, &quot;updateBy&quot;: null, &quot;clearance&quot;: null, &quot;liftNum&quot;: null, &quot;sysOrgCode_dictText&quot;: &quot;漳州市质量安全监督站&quot;, &quot;designUserId&quot;: null, &quot;supervisionId&quot;: &quot;9d2cfda3ddd14946a0bb747090b4b40a&quot;, &quot;cost&quot;: &quot;99999&quot;, &quot;supervisionUserId&quot;: null, &quot;length&quot;: 100, &quot;updateTime&quot;: &quot;2022-01-12 10:34:09&quot;, &quot;isSubmit&quot;: &quot;0&quot;, &quot;endPoint&quot;: null, &quot;createBy&quot;: &quot;admin&quot;, &quot;underGroundNum&quot;: null, &quot;material&quot;: null, &quot;createTime&quot;: &quot;2022-01-12 10:34:09&quot;, &quot;structureType&quot;: &quot;8&quot;, &quot;aboveGroundNum&quot;: null, &quot;width&quot;: 100, &quot;designId&quot;: &quot;f1d96846542844d097e008a7ad5987fe&quot;, &quot;secureUserId&quot;: null, &quot;span&quot;: null, &quot;theSizeOfThe&quot;: &quot;100m&quot;&#125; 专业编辑接口：/qydzh/modules/unitMajorRel 请求方式：post 请求参数 1234567&#123; &quot;arrMajorId&quot;: [ &quot;1448121297935400962&quot;, &quot;1446650928816926722&quot; ], &quot;unitProjectId&quot;: &quot;1481092100704387074&quot;&#125; 工程删除接口：/qydzh/modules/unitProject/del 请求方式：get 请求参数 1id: 授权查询接口：/qydzh/modules/projectCompanyRel/getTree 请求方式：get 请求参数 123456pageNo: 1pageSize: 10total: 21departName: 测试unitProjectId: 1478892509057773570projectId: 1478892374697439233 授权确定接口：/qydzh/modules/projectCompanyRel 请求方式：put 请求参数 12345678910111213&#123; &quot;relIdList&quot;: [ null ], &quot;companyIdList&quot;: [ &quot;e356b8d9-2f03-4d2b-af47-361b4a06a976&quot; ], &quot;viewStatusList&quot;: [ &quot;1&quot; ], &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;unitProjectId&quot;: &quot;1478892509057773570&quot;&#125; 归档目录配置专业查询接口：/qydzh/modules/unitMajorRel 请求方式：get 请求参数 1unitProjectId: 1478892509057773570 标准目录树查询接口：/qydzh/modules/dictionaryStandard/getTree 请求方式：get 请求参数 1majorId: 1448121297935400962 目录查询接口：/qydzh/modules/unitProjectStandardRel 请求方式：get 请求参数 12dictionaryMajorId: 1448121297935400962unitProjectId: 1478892509057773570 配置确定接口：/qydzh/modules/unitProjectStandardRel/editList 请求方式：post 请求参数 12345678910111213141516171819202122232425262728293031&#123; &quot;addList&quot;: [ &#123; &quot;dictionaryMajorId&quot;: &quot;1448121297935400962&quot;, &quot;dictionaryStandardId&quot;: &quot;1455842407764815892&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;unitProjectId&quot;: &quot;1478892509057773570&quot;, &quot;name&quot;: &quot;监理文件&quot; &#125; ], &quot;delList&quot;: [ &#123; &quot;dictionaryMajorId&quot;: &quot;1448121297935400962&quot;, &quot;updateTime&quot;: &quot;2022-01-06&quot;, &quot;isSubmit&quot;: &quot;0&quot;, &quot;delFlag&quot;: &quot;0&quot;, &quot;version&quot;: 1, &quot;dictionaryStandardId&quot;: &quot;1455842316035387397&quot;, &quot;createBy&quot;: &quot;js&quot;, &quot;areaCode&quot;: &quot;350600&quot;, &quot;createTime&quot;: &quot;2022-01-06&quot;, &quot;updateBy&quot;: null, &quot;dictionaryStandardId_dictText&quot;: &quot;工程复工报审表&quot;, &quot;unitProjectId&quot;: &quot;1478892509057773570&quot;, &quot;sysOrgCode&quot;: &quot;A40&quot;, &quot;id&quot;: &quot;1478932167559299076&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;name&quot;: &quot;工程复工报审表&quot; &#125; ]&#125; 部位规划X-Access-Token: 1eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjE2NDE5NjAwMjksInVzZXJuYW1lIjoianMifQ.4NNYMNhmmE5mCY8QwAGb3wtUvEItnm4OH3QALHpv3eU 项目树查询接口： 1/qydzh/modules/project/queryTreeById 请求方式：post 请求参数 123456&#123; &quot;treeType&quot;: &quot;part&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;check&quot;: false, &quot;doubt&quot;: true&#125; 工序目录查询接口： 1/qydzh/modules/process/getTree 请求方式：post 请求参数 1234&#123; &quot;nodeType&quot;: &quot;unitProject&quot;, &quot;unitProjectId&quot;: &quot;1478892448345223169&quot;&#125; 新建部位接口： 1/qydzh/modules/part 请求方式：post 请求参数 123456789&#123; &quot;arrName&quot;: [ &quot;测试1&quot; ], &quot;parentId&quot;: &quot;1480870521261060097&quot;, &quot;partType&quot;: &quot;1&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;unitProjectId&quot;: &quot;1478892448345223169&quot;&#125; 编辑部位接口： 1/qydzh/modules/part 请求方式：put 请求参数 1234567891011121314151617&#123; &quot;moveStyle&quot;: 1, &quot;part&quot;: &#123; &quot;name&quot;: &quot;1层111&quot;, &quot;id&quot;: &quot;1481099351678730241&quot;, &quot;parentId&quot;: &quot;0&quot;, &quot;parentIds&quot;: &quot;0&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;unitProjectId&quot;: &quot;1478892448345223169&quot;, &quot;viewIndex&quot;: 3 &#125;, &quot;selectId&quot;: &quot;1481099351712284674&quot;, &quot;selectIndex&quot;: 2, &quot;selectParentId&quot;: &quot;0&quot;, &quot;selectParentIds&quot;: &quot;0&quot;, &quot;selectUnitProjectId&quot;: &quot;1478892448345223169&quot;&#125; 复制部位接口： 1/qydzh/modules/part/copy 请求方式：post 请求参数 1234567891011&#123; &quot;arrDictionaryProcessId&quot;: [], &quot;arrPartName&quot;: [ &quot;a-1层&quot;, &quot;a-2层&quot;, &quot;a-3层&quot;, &quot;a-4层&quot; ], &quot;selectedPartId&quot;: &quot;1481099351678730241&quot;, &quot;partType&quot;: 0&#125; 删除部位接口： 1/qydzh/modules/part/&#123;id&#125; 请求方式：DELETE 请求参数 无 工序配置目录树查询接口：/qydzh/modules/dictionaryProcess/getTree 请求方式：get 请求参数 12majorId: 1446650928816926722type: 0 关联工序查询接口： 1/qydzh/modules/process/getProcessName 请求方式：get 请求参数 12unitProjectId: 1478892448345223169projectId: 1478892374697439233 工序删除接口： 1/qydzh/modules/process/delete 请求方式：put 请求参数 1234567891011121314&#123; &quot;dictionaryProcessIdList&quot;: [ &quot;1455884298636013569&quot; ], &quot;partIdList&quot;: [ &quot;1478892448345223169&quot; ], &quot;unitProject&quot;: &quot;1478892448345223169&quot;, &quot;project&quot;: &quot;1478892448345223169&quot;, &quot;dictionaryMajorId&quot;: &quot;1446650928816926722&quot;, &quot;nodeType&quot;: &quot;unitProject&quot;, &quot;unitProjectId&quot;: &quot;1478892448345223169&quot;, &quot;projectId&quot;: &quot;1478892374697439233&quot;&#125; 工序添加接口： 1/qydzh/modules/process 请求方式：post 请求参数 1234567891011&#123; &quot;arrDictionaryProcessId&quot;: [ &quot;1455884299227410434&quot; ], &quot;projectId&quot;: &quot;1478892374697439233&quot;, &quot;dictionaryMajorId&quot;: &quot;1446650928816926722&quot;, &quot;unitProjectIdList&quot;: [ &quot;1478892448345223169&quot; ], &quot;nodeType&quot;: &quot;unitProject&quot;&#125; 批量工序配置接口： 1/qydzh/modules/process 请求方式：POST 请求参数 12345678910&#123; &quot;arrDictionaryProcessId&quot;: [ &quot;1455884298438881282&quot;, &quot;1479631512677576706&quot; ], &quot;nodeType&quot;: &quot;project&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot;, &quot;objList&quot;: [], &quot;unitProjectIdList&quot;: []&#125; 批量删除工序查询配置接口： 1/qydzh/modules/process/getAssociation 请求方式：get 请求参数 1/qydzh/modules/process/getAssociation?_t=1641979324&amp;projectId=1481168011399151618 批量删除确定接口： 1/qydzh/modules/process/delProcess 请求方式：post 请求参数 12345678910&#123; &quot;partId&quot;: null, &quot;unitProjectId&quot;: null, &quot;projectId&quot;: &quot;1481168011399151618&quot;, &quot;processIdList&quot;: [ &quot;1455885017611022337&quot;, &quot;1455885017938178049&quot;, &quot;1479631512677576706&quot; ]&#125; 参建单位保存接口： 1/qydzh/modules/projectDepartRel 请求方式：post 请求参数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[ &#123; &quot;departIds&quot;: [ &quot;abe9e7e602f74736b768b0f029ff9917&quot;, &quot;eba9cb3b159b4231ba6e35b885b2492f&quot;, &quot;40bed30b675d4a168acb3c6da7215a95&quot; ], &quot;departLabel&quot;: &quot;001&quot;, &quot;departUse&quot;: &quot;1&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [], &quot;departLabel&quot;: &quot;002&quot;, &quot;departUse&quot;: &quot;1&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [], &quot;departLabel&quot;: &quot;003&quot;, &quot;departUse&quot;: &quot;1&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [ &quot;124a98694e2c4434a83a146871023588&quot; ], &quot;departLabel&quot;: &quot;001&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [ &quot;88eefdf9aa5243e7847df51fdb66275a&quot; ], &quot;departLabel&quot;: &quot;002&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [ &quot;9d2cfda3ddd14946a0bb747090b4b40a&quot; ], &quot;departLabel&quot;: &quot;003&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [ &quot;f1d96846542844d097e008a7ad5987fe&quot; ], &quot;departLabel&quot;: &quot;004&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [ &quot;a3902898c45c40da9c1443221e597efd&quot; ], &quot;departLabel&quot;: &quot;005&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [], &quot;departLabel&quot;: &quot;006&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [], &quot;departLabel&quot;: &quot;007&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;, &#123; &quot;departIds&quot;: [], &quot;departLabel&quot;: &quot;008&quot;, &quot;departUse&quot;: &quot;2&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot; &#125;] 文件管理目录树查询接口： 1/qydzh/modules/project/queryOrderListById 请求方式：post 请求参数： 1234567891011&#123; &quot;column&quot;: &quot;createTime&quot;, &quot;order&quot;: &quot;desc&quot;, &quot;check&quot;: false, &quot;doubt&quot;: true, &quot;nodeType&quot;: &quot;project&quot;, &quot;sub&quot;: false, &quot;projectId&quot;: &quot;1481168011399151618&quot;, &quot;pageNo&quot;: 1, &quot;pageSize&quot;: 10&#125; 目录树评论查询接口： 1/qydzh/modules/comment/getComment 请求方式：post 请求参数： 1234&#123; &quot;nodeType&quot;: &quot;project&quot;, &quot;projectId&quot;: &quot;1481168011399151618&quot;&#125;","categories":[],"tags":[]},{"title":"如何优雅的在centos上使用nginx","slug":"如何优雅的在centos上使用nginx","date":"2022-01-11T17:08:19.000Z","updated":"2022-01-11T18:03:47.242Z","comments":true,"path":"posts/27f7e408.html","link":"","permalink":"https://www.i100.xyz/posts/27f7e408.html","excerpt":"nginx基本配置安装nginx用yum进行安装必要程序 12yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 编辑安装环境 1vim /etc/yum.repos.d/nginx.repo 复制下面的代码 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1 配置完成，然后执行安装 1yum install nginx 查看nginx版本 1nginx -v 查看nginx安装目录1rpm -ql nginx","text":"nginx基本配置安装nginx用yum进行安装必要程序 12yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 编辑安装环境 1vim /etc/yum.repos.d/nginx.repo 复制下面的代码 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1 配置完成，然后执行安装 1yum install nginx 查看nginx版本 1nginx -v 查看nginx安装目录1rpm -ql nginx rpm 是linux的rpm包管理工具，-q 代表询问模式，-l 代表返回列表，这样我们就可以找到nginx的所有安装位置了。 nginx.conf文件解读nginx.conf 文件是Nginx总配置文件，在我们搭建服务器时经常调整的文件。进入etc/nginx目录下，然后用vim进行打开 12cd /etc/nginxvim nginx.conf 下面是文件的详细注释 12345678910111213141516171819202122232425262728293031#运行用户，默认即是nginx，可以不进行设置user nginx;#Nginx进程，一般设置为和CPU核数一样worker_processes 1; #错误日志存放目录error_log /var/log/nginx/error.log warn;#进程pid存放位置pid /var/run/nginx.pid;events &#123; worker_connections 1024; # 单个后台进程的最大并发数&#125;http &#123; include /etc/nginx/mime.types; #文件扩展名与类型映射表 default_type application/octet-stream; #默认文件类型 #设置日志模式 log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; access_log /var/log/nginx/access.log main; #nginx访问日志存放位置 sendfile on; #开启高效传输模式 #tcp_nopush on; #减少网络报文段的数量 keepalive_timeout 65; #保持连接的时间，也叫超时时间 #gzip on; #开启gzip压缩 include /etc/nginx/conf.d/*.conf; #包含的子配置项位置和文件 default.conf 配置进入conf.d目录，然后使用vim default.conf进行查看。 1234567891011121314151617181920212223242526272829303132333435363738394041424344server &#123; listen 80; #配置监听端口 server_name localhost; //配置域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; location / &#123; root /usr/share/nginx/html; #服务默认启动目录 index index.html index.htm; #默认访问文件 &#125; #error_page 404 /404.html; # 配置404页面 # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; #错误状态码的显示页面，配置后需要重启 location = /50x.html &#123; root /usr/share/nginx/html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125;&#125; 明白了这些配置项，我们知道我们的服务目录放在了/usr/share/nginx/html下，可以使用命令进入看一下目录下的文件。 12cd /usr/share/nginx/htmlls 可以看到目录下面有两个文件，50x.html 和 index.html。我们可以使用vim进行编辑。 安全组开启阿里云的安全组配置步骤如下： 进入阿里云控制台，并找到ECS实例。 点击实例后边的“更多” 点击“网络和安全组” ，再点击“安全组配置” 右上角添加“安全组配置” 进行80端口的设置。nginx服务命令启动nginx服务nginx直接启动在CentOS7.4版本里（低版本是不行的），是可以直接直接使用nginx启动服务的。1nginx 使用systemctl命令启动还可以使用个Linux的命令进行启动，我一般都是采用这种方法进行使用。因为这种方法无论启动什么服务，都是一样的，只是换一下服务的名字（不用增加额外的记忆点）。1systemctl start nginx.service 输入命令后，没有任何提示，那我们如何知道Nginx服务已经启动了哪？可以使用Linux的组合命令，进行查询服务的运行状况。1ps aux | grep nginx 如果有三条记录，说明Nginx被正常开启了。停止nginx服务的四种方法停止Nginx 方法有很多种，可以根据需求采用不一样的方法，一个一个说明。立即停止服务1nginx -s stop 这种方法比较强硬，无论进程是否在工作，都直接停止进程。从容停止服务1nginx -s quit 这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。killall方法杀死进程1killall nginx 这种方法也是比较野蛮的，我们直接杀死进程，但是在上面使用没有效果时，我们用这种方法还是比较好的。systemctl停止服务1systemctl stop nginx.service 重启nginx服务有时候要重启nginx服务，可以使用下面的命令1systemctl restart nginx.service 重新载入配置文件在重新编写或者修改Nginx的配置文件后，都需要作一下重新载入，这时候可以用Nginx给的命令。1nginx -s reload 查看端口号在默认情况下，Nginx启动后会监听80端口，从而提供HTTP访问，如果80端口已经被占用则会启动失败。我么可以使用netstat -tlnp命令查看端口号的占用情况。自定义错误页和访问设置一个好的网站会武装到牙齿，任何错误都有给用户友好的提示。比如当网站遇到页面没有找到的时候，我们要提示页面没有找到，并给用户可返回性。错误的种类有很多，所以真正的好产品会给顾客不同的返回结果。多错误指向一个页面在/etc/nginx/conf.d/default.conf 是可以看到下面这句话的。1error_page 500 502 503 504 /50x.html; error_page指令用于自定义错误页面，500，502，503，504 这些就是HTTP中最常见的错误代码，/50.html 用于表示当发生上述指定的任意一个错误的时候，都是用网站根目录下的/50.html文件进行处理。单独为错误置顶处理方法有些时候是要把这些错误页面单独的表现出来，给用户更好的体验。所以就要为每个错误码设置不同的页面。设置方法如下：1error_page 404 /404_error.html; 然后到网站目录下新建一个404_error.html 文件，并写入一些信息。123456&lt;html&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;body&gt;&lt;h1&gt;404页面没有找到!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 然后重启我们的服务，再进行访问，你会发现404页面发生了变化。错误码换成一个地址处理错误的时候，不仅可以只使用本服务器的资源，还可以使用外部的资源。比如我们将配置文件设置成这样。1error_page 404 https://i100.xyz; 简单服务控制有时候我们的服务器只允许特定主机访问，比如内部OA系统，或者应用的管理后台系统，更或者是某些应用接口，这时候我们就需要控制一些IP访问，我们可以直接在location里进行配置。1234location / &#123; deny 123.9.51.42; allow 45.76.202.231; &#125; 配置完成后，重启一下服务器就可以实现限制和允许访问了。nginx访问权限简单接触了Nginx访问简单用法，简单的知道了，deny是禁止访问，allow是允许访问。但Nginx的访问控制还是比较复杂的。指令优先级1234location / &#123; allow 45.76.202.231; deny all; &#125; 上面的配置表示只允许45.76.202.231进行访问，其他的IP是禁止访问的。但是如果我们把deny all指令，移动到 allow 45.76.202.231之前，会发生什么那？会发现所有的IP都不允许访问了。这说明了一个问题：就是在同一个块下的两个权限指令，先出现的设置会覆盖后出现的设置（也就是谁先触发，谁起作用）。复杂访问控制权限匹配在工作中，访问权限的控制需求更加复杂，例如，对于网站下的img（图片目录）是运行所有用户访问，但对于网站下的admin目录则只允许公司内部固定IP访问。这时候仅靠deny和allow这两个指令，是无法实现的。我们需要location块来完成相关的需求匹配。123456location =/img&#123; allow all;&#125;location =/admin&#123; deny all;&#125; =号代表精确匹配，使用了=后是根据其后的模式进行精确匹配。这个直接关系到我们网站的安全，一定要学会。使用正则表达式设置访问权限只有精确匹配有时是完不成我们的工作任务的，比如现在我们要禁止访问所有php的页面，php的页面大多是后台的管理或者接口代码，所以为了安全我们经常要禁止所有用户访问，而只开放公司内部访问的。123location ~\\.php$ &#123; deny all; &#125; 这样我们再访问的时候就不能访问以php结尾的文件了。是不是让网站变的安全很多了那？nginx反向代理设置现在的web模式基本的都是标准的CS结构，即Client端到Server端。那代理就是在Client端和Server端之间增加一个提供特定功能的服务器，这个服务器就是我们说的代理服务器。正向代理如果你觉的反向代理不好理解，那先来了解一下正向代理。我相信作为一个手速远超正常人的程序员来说，你一定用过翻墙工具（我这里说的不是物理梯子），它就是一个典型的正向代理工具。它会把我们不让访问的服务器的网页请求，代理到一个可以访问该网站的代理服务器上来，一般叫做proxy服务器，再转发给客户。简单来说就是你想访问目标服务器的权限，但是没有权限。这时候代理服务器有权限访问服务器，并且你有访问代理服务器的权限，这时候你就可以通过访问代理服务器，代理服务器访问真实服务器，把内容给你呈现出来。反向代理反向代理跟代理正好相反（需要说明的是，现在基本所有的大型网站的页面都是用了反向代理），客户端发送的请求，想要访问server服务器上的内容。发送的内容被发送到代理服务器上，这个代理服务器再把请求发送到自己设置好的内部服务器上，而用户真实想获得的内容就在这些设置好的服务器上。proxy服务器代理的并不是客户端，而是服务器,即向外部客户端提供了一个统一的代理入口，客户端的请求都要先经过这个proxy服务器。具体访问那个服务器server是由Nginx来控制的。再简单点来讲，一般代理指代理的客户端，反向代理是代理的服务器反向代理的用途和好处 安全性：正向代理的客户端能够在隐藏自身信息的同时访问任意网站，这个给网络安全代理了极大的威胁。因此，我们必须把服务器保护起来，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。 功能性：反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。最简单的反向代理现在我们要访问http://nginx2.i100.com然后反向代理到i00.com这个网站。我们直接到etc/nginx/con.d/8001.conf进行修改。1234567server&#123; listen 80; server_name nginx2.i100.com; location / &#123; proxy_pass http://i100.com; &#125;&#125; 一般我们反向代理的都是一个IP，但是我这里代理了一个域名也是可以的。其实这时候我们反向代理就算成功了其它反向代理指令proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。nginx适配PC或移动设备现在很多网站都是有了PC端和H5站点的，因为这样就可以根据客户设备的不同，显示出体验更好的，不同的页面了。这样的需求有人说拿自适应就可以搞定，比如我们常说的bootstrap和24格布局法，这些确实是非常好的方案，但是无论是复杂性和易用性上面还是不如分开编写的好，比如我们常见的淘宝、京东……这些大型网站就都没有采用自适应，而是用分开制作的方式。$http_user_agent的使用Nginx通过内置变量$http_user_agent，可以获取到请求客户端的userAgent，就可以用户目前处于移动端还是PC端，进而展示不同的页面给用户。操作步骤如下： 1.在/usr/share/nginx/目录下新建两个文件夹，分别为：pc和mobile目录123cd /usr/share/nginxmkdir pcmkdir mobile 在pc和miblic目录下，新建两个index.html文件，文件里下面内容1&lt;h1&gt;I am pc!&lt;/h1&gt; 1&lt;h1&gt;I am mobile!&lt;/h1&gt; 进入etc/nginx/conf.d目录下，修改8001.conf文件，改为下面的形式:1234567891011server&#123; listen 80; server_name nginx2.jspang.com; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &#x27;(Android|webOS|iPhone|iPod|BlackBerry)&#x27;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; nginx的Gzip压缩配置Gzip是网页的一种网页压缩技术，经过gzip压缩后，页面大小可以变为原来的30%甚至更小。更小的网页会让用户浏览的体验更好，速度更快。gzip网页压缩的实现需要浏览器和服务器的支持。gzip是需要服务器和浏览器同事支持的。当浏览器支持gzip压缩时，会在请求消息中包含Accept-Encoding:gzip,这样Nginx就会向浏览器发送听过gzip后的内容，同时在相应信息头中加入Content-Encoding:gzip，声明这是gzip后的内容，告知浏览器要先解压后才能解析输出。gzip的配置项Nginx提供了专门的gzip模块，并且模块中的指令非常丰富。 gzip : 该指令用于开启或 关闭gzip模块。 gzip_buffers : 设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。 gzip_comp_level : gzip压缩比，压缩级别是1-9，1的压缩级别最低，9的压缩级别最高。压缩级别越高压缩率越大，压缩时间越长。 gzip_disable : 可以通过该指令对一些特定的User-Agent不使用压缩功能。 gzip_min_length:设置允许压缩的页面最小字节数，页面字节数从相应消息头的Content-length中进行获取。 gzip_http_version：识别HTTP协议版本，其值可以是1.1.或1.0. gzip_proxied : 用于设置启用或禁用从代理服务器上收到相应内容gzip压缩。 gzip_vary : 用于在响应消息头中添加Vary：Accept-Encoding,使代理服务器根据请求头中的Accept-Encoding识别是否启用gzip压缩。Gzip最简单配置123456http &#123; ..... gzip on; gzip_types text/plain application/javascript text/css; .....&#125; gzip on是启用gizp模块，下面的一行是用于在客户端访问网页时，对文本、JavaScript 和CSS文件进行压缩输出。配置好后，我们就可以重启Nginx服务，让我们的gizp生效了。如果你是windows操作系统，你可以按F12键打开开发者工具，单机当前的请求，在标签中选择Headers，查看HTTP响应头信息。你可以清楚的看见Content-Encoding为gzip类型。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.i100.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://www.i100.xyz/tags/centos/"},{"name":"nginx","slug":"nginx","permalink":"https://www.i100.xyz/tags/nginx/"}]},{"title":"如何优雅的使用ES6","slug":"如何优雅的使用ES6","date":"2022-01-11T00:58:45.000Z","updated":"2022-01-11T16:55:25.947Z","comments":true,"path":"posts/e38dcee3.html","link":"","permalink":"https://www.i100.xyz/posts/e38dcee3.html","excerpt":"解构赋值解构的默认值undefined不支持，null相当于有值，但值为null 1234let [foo = true] = [];console.log(&#x27;log&#x27;,foo)let [a,b=&quot;i100&quot;]=[&#x27;百里&#x27;]console.log(a+b); //控制台显示“百里i100” 注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。","text":"解构赋值解构的默认值undefined不支持，null相当于有值，但值为null 1234let [foo = true] = [];console.log(&#x27;log&#x27;,foo)let [a,b=&quot;i100&quot;]=[&#x27;百里&#x27;]console.log(a+b); //控制台显示“百里i100” 注意：对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 圆括号的使用在解构之前定义了变量在解构会报错，解决方法是在整体的外边加一个括号 123let foo;(&#123;foo&#125; = &#123;foo: &#x27;i100&#x27;&#125;);console.log(&#x27;log&#x27;,foo); 字符串解构12const [a,b,c,d] = &#x27;test&#x27;console.log(&#x27;log&#x27;,a,b,c,d) // t,e,s,t 扩展与rest运算符对象扩展运算符编写一个方法，允许入参是不确定的 1234function i100 (...arg) &#123; console.log(&#x27;log&#x27;,arg[0],arg[1])&#125;i100(1,2,3) 扩展运算符用处声明2个数组arr1，arr2，把arr1赋值给arr2，然后改变arr2的值发现arr1的值也变了，这是对内存堆栈的引用，不是真正的赋值 12345let arr1 = [&#x27;www&#x27;,&#x27;i100&#x27;,&#x27;xyz&#x27;];let arr2 = arr1;console.log(&#x27;log&#x27;,arr2)arr2.push(&#x27;add&#x27;)console.log(&#x27;i100&#x27;,arr1) 我们可以利用扩展运算符 1let arr2 = [...arr1] rest运算符与对象扩展运算符有相似之处 1234function i100(first,...rest) &#123; console.log(&#x27;i100&#x27;,resr.length)&#125;i100(0,1,2,3) 模板字符串简单使用12let i100 = &#x27;百里&#x27;;let blog = `这是$&#123;i100&#125;的博客` 对运算的支持123let a=1;let b=2;let sum = `$&#123;a+b&#125;` 字符串查询 查询全部1let res = blog.includes(i100) 查询开头1let res = blog.startsWith(i100) 查询结尾1let res = blog.endsWith(i100) 新增数组知识JSON格式转换特殊的json格式都可以轻松使用ES6的语法转变成数组12345678let json = &#123; &#x27;0&#x27;: &#x27;i100&#x27;, &#x27;1&#x27;: &#x27;百里&#x27;, &#x27;2&#x27;: &#x27;博客&#x27;, length: 3&#125;let arr = Array.from(json)console.log(&#x27;i100&#x27;,arr) Array.of()方法它负责把一堆文本或者变量转换成数组。12let arr = Array.of(1,2,3,4)console.log(&#x27;i100&#x27;,arr) find()实例方法find方法是从数组中查找。在find方法中我们需要传入一个匿名函数，函数需要传入三个参数： value：表示当前查找的值。 index：表示当前查找的数组索引。 arr：表示当前数组。在函数中如果找到符合条件的数组元素就进行return，并停止查找。1234let arr = [1,2,3,4,5];let res = arr.find(function(value, index, arr) &#123; return value &gt; 2;&#125;) fill()实例方法fill()也是一个实例方法，它的作用是把数组进行填充，它接收三个参数，第一个参数是填充的变量，第二个是开始填充的位置，第三个是填充到的位置。123let arr = [1,2,3,4,5];arr.fill(&#x27;i100&#x27;,2,3)// 上边的代码是把数组从第二位到第三位用i100进行填充。 数组的遍历 for…of循环这种形式比ES5的for循环要简单而且高效。先来看一个最简单的for…of循环1234let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];for (let item of arr) &#123; console.log(&#x27;i100&#x27;,item);&#125; for…of数组索引:有时候开发中是需要数组的索引的，那我们可以使用下面的代码输出数组索引1234let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];for (let index of arr.keys()) &#123; console.log(&#x27;i100&#x27;,index);&#125; 同时输出数组的内容和索引：我们用entries()这个实例方法，配合我们的for…of循环就可以同时输出内容和索引了。1234let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];for (let [index,val] of arr.entries()) &#123; console.log(&#x27;i100&#x27;,index+&#x27;:&#x27;+val)&#125; entries实例方法entries()实例方式生成的是Iterator形式的数组，那这种形式的好处就是可以让我们在需要时用next()手动跳转到下一个值。12345let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];let list = arr.entries();console.log(&#x27;i100-1&#x27;,list.next().value);console.log(&#x27;i100-2&#x27;,list.next().value);console.log(&#x27;i100-3&#x27;,list.next().value); 箭头函数和扩展默认值12345function add(a,b=1) &#123; return a+b;&#125;console.log(&#x27;i100&#x27;,add(1)); 主动抛出错误1234567function add(a,b=1) &#123; if(a==0) &#123; throw new Error(&#x27;This is error&#x27;) &#125; return a+b;&#125;console.log(&#x27;i100&#x27;,add(0)) 箭头函数箭头函数中不可加new，也就是说箭头函数不能当构造函数进行使用1234let add = (a,b=1) =&gt; &#123; return a+b;&#125; console.log(&#x27;i100&#x27;,add(1)) 函数与数组的补漏对象的函数解构123456789let json = &#123; a: &#x27;i100&#x27;, b: &#x27;百里&#x27;, c: &#x27;博客&#x27;&#125;function fun(&#123;a,b=&#x27;test&#x27;&#125;) &#123; console.log(&#x27;i100&#x27;,a,b)&#125;fun(json) 数组函数解构声明一个数组，然后写一个方法，最后用…进行解构赋值。12345let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];function fun(a,b,c) &#123; console.log(&#x27;i100&#x27;,a,b,c)&#125;fun(...arr) in的用法 in是用来判断对象或者数组中是否存在某个值的 对象判断123456let obj = &#123; a: &#x27;i100&#x27;, b: &#x27;百里&#x27;, c: &#x27;博客&#x27;&#125;console.log(&#x27;i100&#x27; in obj); // true 数组判断先来看一下ES5判断的弊端，以前会使用length属性进行判断，为0表示没有数组元素。但是这并不准确，或者说真实开发中有弊端。12let arr = [,,,,,];console.log(&#x27;i100&#x27;,arr.length); // 5 上边的代码输出了5，但是数组中其实全是空值，这就是一个坑啊。那用ES6的in就可以解决这个问题。1234let arr = [,,,,,];console.log(&#x27;i100&#x27;,0 in arr); // falselet arr1 = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];console.log(&#x27;i100&#x27;,0 in arr1) // true 这里的0指的是数组下标位置是否为空。 数组遍历用法 forEach12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,,&#x27;博客&#x27;];arr.forEach((val,index)=&gt;console.log(&#x27;i100&#x27;,index,val)) forEach循环的特点是会自动省略为空的数组元素，相当于直接给我们筛空了。当是有时候也会给我们帮倒忙。 filter12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];arr.filter(x=&gt;console.log(x)); some12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];arr.some(x=&gt;console.log(x)); map12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];console.log(&#x27;i100&#x27;,arr.map(x=&gt;&#x27;wb&#x27;)); map在这里起到一个替换的作用 数组转换字符串 在开发中我们经常会碰到把数组输出成字符串的形式，我们今天学两种方法，你要注意两种方法的区别 join 12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];console.log(&#x27;i100&#x27;,arr.join(&#x27;|&#x27;)) join()方法就是在数组元素中间，加了一些间隔，开发中很有用处 toString 12let arr = [&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;];console.log(&#x27;i100&#x27;,arr.toString()); 转换时只是是用逗号隔开了。 ES6对象对象对于Javascript是非常重要的。在ES6中对象有了很多新特性。###对象赋值 ES6允许把声明的变量直接赋值给对象 1234let name = &#x27;i100&#x27;;let skill = &#x27;web&#x27;;let obj = &#123;name,skill&#125;console.log(&#x27;i100&#x27;,obj); 对象Key值构建有时候我们会在后台取出key值，而不是我们前台定义好的，这时候我们如何构建我们的key值那。比如我们在后台取了一个key值，然后可以用[ ] 的形式，进行对象的构建。 12345let key = &#x27;skill&#x27;;let obj = &#123; [key]: &#x27;web&#x27;&#125;console.log(&#x27;i100&#x27;,obj.skill); 自定义对象方法 对象方法就是把兑现中的属性，用匿名函数的形式编程方法 123456let obj = &#123; add: function(a,b) &#123; return a + b; &#125;&#125;console.log(&#x27;i100&#x27;,obj.add(1,2)); Object.is()对象比较对象的比较方法,以前进行对象值的比较，经常使用===来判断，比如下面的代码： 1234let obj1 = &#123;name:&#x27;lisi&#x27;&#125;;let obj2 = &#123;name:&#x27;xiaoming&#x27;&#125;;let res = Object.is(obj1,obj2);console.log(&#x27;i100&#x27;,res); Object.assign()合并对象 12345let a=&#123;a:&#x27;a&#x27;&#125;let b=&#123;b:&#x27;b&#x27;&#125;let c=&#123;c:&#x27;c&#x27;&#125;let d=Object.assign(a,b,c);console.log(&#x27;i100&#x27;,d); Symbol在对象的作用声明Symbol123let g = Symbol(&#x27;i100&#x27;);console.log(&#x27;i100&#x27;,g);console.log(&#x27;i100&#x27;,g.toString()); 这时候我们仔细看控制台是有区别的，没有toString的是红字，toString的是黑字。 Symbol在对象中的应用1234567let i100 = Symbol();let obj = &#123; [i100]: &#x27;百里&#x27;&#125;console.log(&#x27;i100&#x27;,obj[i100]);obj[i100]=&#x27;web&#x27;;console.log(&#x27;i100&#x27;,obj[i100]); Symbol对象元素的保护作用 在对象中有很多值，但是循环输出时，并不希望全部输出，那我们就可以使用Symbol进行保护。 没有进行保护的写法： 12345678let obj = &#123; a: &#x27;i100&#x27;, b: &#x27;百里&#x27;, c: &#x27;博客&#x27;&#125;;for(let item in obj) &#123; console.log(&#x27;i100&#x27;,obj[item]);&#125; 现在我不想别人知道我的年龄，这时候我就可以使用Symbol来进行循环保护。 12345678910let obj = &#123; a: &#x27;i100&#x27;, b: &#x27;百里&#x27;,&#125;;let age = Symbol();obj[age] = 18;for(let item in obj) &#123; console.log(&#x27;i100&#x27;,obj[item]);&#125;console.log(&#x27;i100&#x27;,obj); Set数据结构 Set数据结构，注意这里不是数据类型，而是数据结构。它是ES6中新的东西，并且很有用处。Set的数据结构是以数组的形式构建的。 Set声明12let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);console.log(&#x27;i100&#x27;,setArr); // Set(3) &#123;&#x27;i100&#x27;, &#x27;百里&#x27;, &#x27;博客&#x27;&#125; Set和Array 的区别是Set不允许内部有重复的值，如果有只显示一个，相当于去重。虽然Set很像数组，但是他不是数组。 Set值的增删查 追加add在使用Array的时候，可以用push进行追加值，那Set稍有不同，它用更语义化的add进行追加 123let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);setArr.add(&#x27;前端&#x27;);console.log(&#x27;i100&#x27;,setArr); 删除delete 123let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);setArr.delete(&#x27;前端&#x27;);console.log(&#x27;i100&#x27;,setArr); 查找has用has进行值的查找，返回的是true或者false。 12let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);setArr.has(&#x27;i100&#x27;); 删除clear 123let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);setArr.clear();console.log(&#x27;i100&#x27;,setArr); set的for…of循环 1234let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);for(let item of setArr) &#123; console.log(&#x27;i100&#x27;,item);&#125; size属性size属性可以获取Set值的数量 12let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);console.log(&#x27;i100&#x27;,setArr.size); forEach循环 12let setArr = new Set([&#x27;i100&#x27;,&#x27;百里&#x27;,&#x27;博客&#x27;]);setArr.forEach((value)=&gt;console.log(value)); Map数据结构在一些构建工具中是非常喜欢使用map这种数据结构来进行配置的，因为map是一种灵活，简单的适合一对一查找的数据结构。 123456789101112let obj = &#123; a: &#x27;i100&#x27;, b: &#x27;百里&#x27;, c: &#x27;博客&#x27;&#125;;console.log(&#x27;i100&#x27;,obj.c);let map = new Map();// 设置valuemap.set(obj,&#x27;test&#x27;);// 设置keymap.set(&#x27;test&#x27;,obj);console.log(&#x27;i100&#x27;,map); 取值get12let res = map.get(obj);console.log(&#x27;i100&#x27;,res); 删除delete删除delete指定值： 1map.delete(obj) size属性1map.size 查找has1map.has(&#x27;i100&#x27;); 清除clear1map.clear() 总结：map在现在开发中已经经常使用，它的灵活性和高效性是我们喜欢的。开发中试着去使用map吧，你一定会喜欢上它的。 用Proxy进行预处理 钩子函数：当我们在操作一个对象或者方法时会有几种动作，比如：在运行函数前初始化一些数据，在改变对象值后做一些善后处理。这些都算钩子函数，Proxy的存在就可以让我们给函数加上这样的钩子函数，你也可以理解为在执行方法前预处理一些代码。你可以简单的理解为他是函数或者对象的生命周期。 Proxy的应用可以使函数更加强大，业务逻辑更加清楚，而且在编写自己的框架或者通用组件时非常好用 回顾定义对象方法 123456789var obj=&#123; add:function(val)&#123; return val+10; &#125;, name:&#x27;I am Jspang&#x27;&#125;;console.log(obj.add(100));console.log(obj.name); 声明Proxy用new的方法对Proxy进行声明。可以看一下声明Proxy的基本形式。 1new Proxy(&#123;&#125;,&#123;&#125;); 需要注意的是这里是两个花括号，第一个花括号就相当于我们方法的主体，后边的花括号就是Proxy代理处理区域，相当于我们写钩子函数的地方。 现在把上边的obj对象改成我们的Proxy形式。 123456789101112let pro = new Proxy(&#123; add: function(val) &#123; return val + 10; &#125;, name: &#x27;I am i100&#x27;&#125;,&#123; get:function(target, key, property) &#123; console.log(&#x27;come in Get&#x27;,target, key, property); return target[key]; &#125;&#125;)console.log(&#x27;i100&#x27;,pro.name); 可以在控制台看到结果，先输出了come in Get。相当于在方法调用前的钩子函数 get属性get属性是在你得到某对象属性值时预处理的方法，他接受三个参数 target：得到的目标值 key：目标的key值，相当于对象的属性 property：这个不太常用，用法还在研究中。set属性set属性是值你要改变Proxy属性值时，进行的预先处理。它接收四个参数。 target:目标值。 key：目标的Key值。 value：要改变的值。 receiver：改变前的原始值。123456789101112131415161718let pro = new Proxy(&#123; add: function(val) &#123; return val + 10; &#125;, name: &#x27;I am i100&#x27;&#125;,&#123; get:function(target, key, property) &#123; console.log(&#x27;come in Get&#x27;,target, key, property); return target[key]; &#125;, set:function(target, key, value, receiver) &#123; console.log(&#x27;i100-set&#x27;,key,value); return target[key] = value; &#125;&#125;)console.log(&#x27;i100&#x27;,pro.name);pro.name = &#x27;李四&#x27;;console.log(&#x27;i100&#x27;,pro.name); apple的使用apply的作用是调用内部的方法，它使用在方法体是一个匿名函数时。123456789101112131415var twice = &#123; //目标对象，目标对象的上下文对象，目标对象的参数数组 apply:function (target,ctx,args) &#123; console.log(&quot;ctx&quot;,ctx,&quot;args&quot;,args); return Reflect.apply(...arguments)*2; &#125;&#125;;function sum (left,right) &#123; return left*right;&#125;;var proxy = new Proxy(sum,twice);console.log(&quot;proxy1&quot;,proxy(1,2));console.log(&quot;proxy.call&quot;,proxy.call(null,5,6));console.log(&quot;proxy,apply&quot;,proxy.apply(null,[7,8]));console.log(&quot;proxy,apply&quot;,Reflect.apply(proxy,null,[7,8])); promise对象的使用 ES6中的promise的出现给我们很好的解决了回调地狱的问题，在使用ES5的时候，在多层嵌套回调时，写完的代码层次过多，很难进行维护和二次开发，ES6认识到了这点问题，现在promise的使用，完美解决了这个问题。 promise基本用法模拟一个多步骤多过程，如在家吃饭需要三个步骤。 开始做饭 坐下来吃饭 🤕️洗碗这个过程是有执行顺序多，确保上一步完成，才能继续下一步操作1234567891011121314151617181920212223242526272829303132333435let state = 1;function step1(resolve,reject) &#123; console.log(&#x27;1.开始做饭&#x27;); if(state) &#123; resolve(&#x27;做饭完成&#x27;); &#125;else&#123; reject(&#x27;做饭出错了&#x27;); &#125;&#125;function step2(resolve,reject) &#123; console.log(&#x27;2.开始吃饭&#x27;); if(state) &#123; resolve(&#x27;吃饭完成&#x27;) &#125;else &#123; reject(&#x27;吃饭出错&#x27;) &#125;&#125;function step3(resolve,reject) &#123; console.log(&#x27;3.开始洗碗&#x27;); if(state) &#123; resolve(&#x27;洗碗完成&#x27;) &#125;else &#123; reject(&#x27;洗碗出错&#x27;) &#125;&#125;new Promise(step1).then(function (val) &#123; console.log(val); return new Promise(step2)&#125;).then(function (val) &#123; console.log(val); return new Promise(step3)&#125;).then(function (val) &#123; console.log(val); return val;&#125;) class类的使用 在ES5中经常使用方法或者对象去模拟类的使用，虽然可以实现功能，但是代码并不优雅，ES6为我们提供了类的使用。需要注意的是我们在写类的时候和ES5中的对象和构造函数要区分开来，不要学混了。 类的声明12345class coder &#123; name(val) &#123; console.log(&#x27;i100&#x27;,val); &#125;&#125; 类的使用123456789101112class Coder&#123; name(val) &#123; console.log(&#x27;i100&#x27;,val); &#125; skill(val) &#123; let res = this.name + val; console.log(&#x27;skill&#x27;,res); &#125;&#125;let i100 = new Coder();i100.name(&#x27;百里&#x27;);i100.skill(&#x27;web&#x27;); 这里需要注意的是两个方法中间不要写逗号了，还有这里的this指类本身，还有要注意return 的用法。类的传参在类的参数传递中我们用constructor( )进行传参。传递参数后可以直接使用this.xxx进行调用。123456789101112131415161718class Coder&#123; name(val) &#123; console.log(&#x27;i100&#x27;,val); &#125; skill(val) &#123; let res = this.name + val; console.log(&#x27;skill&#x27;,res); &#125; constructor(a,b) &#123; this.a = b; this.b = b; &#125; add() &#123; return this.a + this.b; &#125;&#125;let i100 = new Coder(1,2);console.log(&#x27;i100&#x27;,i100); 用constructor来约定了传递参数，然后用作了一个add方法，把参数相加。class的继承12345class htmler extends Coder &#123; &#125;let i100 = new htmler();i100.name(&#x27;百里&#x27;) 声明一个htmler的新类并继承Coder类，htmler新类里边为空，这时候我们实例化新类，并调用里边的name方法。结果也是可以调用到的。模块化操作在ES5中我们要进行模块华操作需要引入第三方类库，随着前后端分离，前端的业务日渐复杂，ES6为我们增加了模块话操作。模块化操作主要包括两个方面。 export :负责进行模块化，也是模块的输出。 import : 负责把模块引，也是模块的引入操作。export的用法export可以让我们把变量，函数，对象进行模块话，提供外部调用接口，让外部进行引用。先来看个最简单的例子，把一个变量模块化。新建一个temp.js文件，然后在文件中输出一个模块变量1export let i00 = &#x27;百里&#x27;; 然后可以在index.js中以import的形式引入。12import &#123;i100&#125; from &#x27;./temp.js&#x27;;console.log(&#x27;i100&#x27;,i100); 这就是一个最简单的模块的输出和引入。as用法有些时候我们并不想暴露模块里边的变量名称，而给模块起一个更语义话的名称，这时候我们就可以使用as来操作。 123456let a = &#x27;i100&#x27;, b = &#x27;百里&#x27;, c = &#x27;web&#x27;;export &#123; x as a, y as b, z as c&#125; export default的使用加上default相当是一个默认的入口。在一个文件里export default只能有一个。我们来对比一下export和export default的区别 export1234export let i100 = &#x27;百里&#x27;;export function add(a,b) &#123; return a+b;&#125; 对应的导入方式 1import &#123;i100,add&#125; from &#x27;./temp&#x27;; export default1export default let i100 = &#x27;百里&#x27;; 对应的导入方式 1import str from &#x27;./temp&#x27;;","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.i100.xyz/categories/ES6/"}],"tags":[{"name":"优雅","slug":"优雅","permalink":"https://www.i100.xyz/tags/%E4%BC%98%E9%9B%85/"}]},{"title":"如何让你的代码更优雅","slug":"如何让你的代码更优雅","date":"2022-01-08T08:35:04.000Z","updated":"2022-01-09T09:36:55.915Z","comments":true,"path":"posts/932a8af7.html","link":"","permalink":"https://www.i100.xyz/posts/932a8af7.html","excerpt":"常量赋值引用数据类型包括接口中返回的数据，要做好兜底 12let lastName = fullName[1] || &#x27;&#x27;let propertyValue=Object.attr || 0 指明类型要按强类型风格写代码定义变量的时候要指明类型，并且在变量声明之后，不要随意的去更改变量的数据类型 123// 假设声明三个变量a,b,clet a,b,c; // difference，定义变量时没有指明类型let a = &quot;&quot;, b = [], c = &#123;&#125;; // good 逻辑判断==逻辑判断注意== 表示只要值相等即为真，=== 要求不仅值相等，而且也要求类型相同使用== 有时候会达不到预期的结果，埋下隐患 123456789100 == &#x27;&#x27; // true0 == &#x27;0&#x27; // true&#x27;&#x27; == 0 // true&#x27;&#x27; == &#x27;0&#x27; // falsefalse == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == undefined // falsefalse == null // falsenull == undefined // truetrue == 1 // true 数据类型不确定如果变量的数据类型不确定，那咱就手动的转换一下，让它确定 12let total = &quot;6&quot;;if(parseInt(total) === 6)&#123;&#125; // grace 手动转换一下数据类型","text":"常量赋值引用数据类型包括接口中返回的数据，要做好兜底 12let lastName = fullName[1] || &#x27;&#x27;let propertyValue=Object.attr || 0 指明类型要按强类型风格写代码定义变量的时候要指明类型，并且在变量声明之后，不要随意的去更改变量的数据类型 123// 假设声明三个变量a,b,clet a,b,c; // difference，定义变量时没有指明类型let a = &quot;&quot;, b = [], c = &#123;&#125;; // good 逻辑判断==逻辑判断注意== 表示只要值相等即为真，=== 要求不仅值相等，而且也要求类型相同使用== 有时候会达不到预期的结果，埋下隐患 123456789100 == &#x27;&#x27; // true0 == &#x27;0&#x27; // true&#x27;&#x27; == 0 // true&#x27;&#x27; == &#x27;0&#x27; // falsefalse == &#x27;0&#x27; // truefalse == &#x27;false&#x27; // falsefalse == undefined // falsefalse == null // falsenull == undefined // truetrue == 1 // true 数据类型不确定如果变量的数据类型不确定，那咱就手动的转换一下，让它确定 12let total = &quot;6&quot;;if(parseInt(total) === 6)&#123;&#125; // grace 手动转换一下数据类型 数组数组拷贝12345let items=[&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;];const itemCopy = [...items]// joining arrays const odd = [1, 3, 5 ]; const nums = [2 ,4 , 6, ...odd]; 变量赋值12const Arr = [1, 2, 3, 4];const [first, second] = Arr; 函数的命名 返回布尔值函数应以is/can/has等单词开头，能够让人更直观的了解到这个函数的功能；获取接口中的数据使用get开头进行命名,动作函数要以动词开头。 12345// gracelet isSupport = () =&gt; &#123;&#125;;let canUpdate = () =&gt; &#123;&#125;;let geUserInfo = (user) =&gt; &#123;&#125;let setUserInfo = (user) =&gt; &#123;&#125; 优先使用箭头函数12// grace 是不是看着更简介优雅了let findAge = (arr, age)=&gt; arr.filter(num =&gt; num === age) 函数的入参函数的入参，是能够让使用者，在调用这个函数的时候，能够更加的清晰明了的把这个函数所需要的参数传递给函数，不容易出现，参数传递错误（参数的顺序颠倒等）一些低级，而又不好查找的问题 12345678910// difference// true和false啥意思，没有个注释的话，看上去就是一脸懵逼function getImages(api, true, false); // grace// 一目了然，知道这些true和false是啥意思function getImages(&#123; imageApi: api, includePageBackground: true, compress: false,&#125;) 接收参数如果函数的的参数是对象，也要优先使用解构赋值，上代码 12345678910111213141516171819202122232425// 假设现在的场景是获取用户的信息上的现用名，和曾用名// differencefunction getFullName(user) &#123; const firstName = user.firstName; const lastName = user.lastName;&#125;// commonlyfunction getFullName(obj) &#123; const &#123; firstName, lastName &#125; = obj;&#125;// gracefunction getFullName(&#123; firstName, lastName &#125;) &#123;&#125;// grace 给它个默认值function getFullName(&#123;firstName, lastName = &#x27;无&#x27;&#125;) &#123;&#125; // 觉得参数的名称太长，咱再来个重命名 解构时重命名简化命名// gracefunction getFullName (&#123;firstName: first, lastName: last&#125;) &#123; &#125; 参数效验更少的嵌套，不满足条件尽早 return，尽可能的减少嵌套，嵌套的层级越少，函数看着越简洁优雅 123456function test(name, sex = 1) &#123; // 不满足条件尽早抛出错误 if (!name)&#123; throw new Error(&#x27;没有传递name参数&#x27;); &#125;&#125; 函数的出参对象作为返回值，更便于以后添加返回值，以及更改返回值的顺序，相对于数组更加的灵活，更便于扩展 1234567891011// 函数返回多个值，推荐使用对象作为函数的返回值// commonlyfunction processInput(input) &#123; return [left, right, top, bottom];&#125;// gracefunction processInput(input) &#123; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, right &#125; = processInput(input); 立即执行函数立即执行函数也推荐写成箭头函数的形式。首先是因为更简洁，并且也绑定好 this（箭头函数不会去改变this的指向）。 123(() =&gt; &#123; console.log(&#x27;立即执行函数&#x27;);&#125;)(); 优先使用函数式编程123456// differencefor(i = 1; i &lt;= 10; i++) &#123; a[i] = a[i] +1;&#125;// gracelet b = a.map(item =&gt; ++item) //是不是更简洁了 函数中过多的采用if else12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// commonlyif (a === 1) &#123; //...&#125; else if (a ===2) &#123; // ...&#125; else if (a === 3) &#123; //...&#125; else &#123; //...&#125; // 一般switch(a) &#123; case 1: //.... case 2: //.... case 3: //.... default: //....&#125;// grace ===》》》 Objectconst fruit = &#123; 1: [&#x27;1&#x27;, &#x27;11&#x27;], 2: [&#x27;2&#x27;, &#x27;22&#x27;], 3: [&#x27;3&#x27;, &#x27;33&#x27;] &#125;;let test = (a) =&gt; &#123; return fruit[a] || [];&#125;// grace ===》》》 Mapconst fruit = newMap() .set(&#x27;张三&#x27;, [&#x27;张三丰&#x27;, &#x27;张三力&#x27;]) .set(&#x27;李四&#x27;, [&#x27;李思维&#x27;, &#x27;李素丽&#x27;])let test = (a) =&gt; &#123; return fruit.get(a) || [];&#125;// grace ===》》》filterconst fruits = [ &#123; name: &#x27;张三&#x27;, work: &#x27;js&#x27; &#125;, &#123; name: &#x27;李四&#x27;, work: &#x27;php&#x27; &#125;, &#123; name: &#x27;王五&#x27;, work: &#x27;java&#x27; &#125;, ];let test = (a) =&gt; &#123; return fruits.filter(item =&gt; item.name === a);&#125;// grace===》》》策略模式let handler = &#123; 1: () =&gt; &#123; //.... &#125;, 2: () =&gt; &#123; //.... &#125;, 3: () =&gt; &#123; //.... &#125;, default: () =&gt; &#123; //.... &#125;&#125;handler[a]() || handler[&#x27;default&#x27;]() 温馨小提示一个函数完成一个独立的功能，不要一个函数混杂多个功能，在项目开发中有一条非常重要的原则【单一原则】所谓的单一原则就是，一个函数（文件），只做一件事情，在开发当中，没有那个项目是开发完成之后，就结束了。需要不断的更新，维护，那么单一原则，就是为了方便开发，和维护的，不要让一个函数“又当爹，又当妈”，这样代码的耦合性太高了，不好维护 其他判断数组长度1234567891011121314151617181920// differenceif (arr.length !== 0) &#123; //...&#125;// graceif (arr.length) &#123; //...&#125;// differenceif (arr.length === 0) &#123; //...&#125;// graceif (!arr.length) &#123; //...&#125; 逻辑运算符12345678910111213141516171819202122if (a === 1) &#123; b()&#125;//可以写成a === 1 &amp;&amp; b()const arr = [1,2,3];if(!arr.length)&#123; b() &#125;//可以写出arr.length || b()// &amp;&amp;判断依赖的键是否存在，防止报错&#x27;xxx of undfined&#x27;let user = &#123; name: &#x27;Symbol卢&#x27;, age: 18, children: &#123; name: &#x27;小Symbol卢&#x27; &#125;&#125;let childrenName = user.children &amp;&amp; user.childre.name 三目运算符1234567891011// differenceconst a = &#x27;&#x27;;let b;if( a === &#x27;&#x27; )&#123; b = &#x27;no&#x27;&#125; else &#123; b = &#x27;ok&#x27;&#125;const a = &#x27;&#x27;let b = a ? &#x27;no&#x27; : &#x27;ok&#x27;; // &#x27;ok&#x27; 函数定义12345678/** * @description: 数据类型的检测的第二种方式 * @param &#123;any&#125; data 要检测数据类型的变量 * @return &#123;string&#125; type 返回具体的类型名称【小写】 */export const isTypeOf = (data) =&gt; &#123; return Object.prototype.toString.call(data).replace(/\\[object (\\w+)\\]/, &#x27;$1&#x27;).toLowerCase()&#125; 使用 Array.includes 来处理多重 || 条件123456789// differenceif (a === 1 || a === 2 || a === 3 || a === 4) &#123; //...&#125;// gracelet arr = [1, 2, 3, 4]if (arr.includes(a)) &#123; //...&#125; 使用 Array.every 和 Array.some 来处理全部/部分满足条件123456789101112// graceconst users = [ &#123; name: &#x27;张三&#x27;, sex:1 &#125;, &#123; name: &#x27;李四&#x27;, sex:2 &#125;, &#123; name: &#x27;王五&#x27;, sex:1 &#125; ];function test() &#123; // 条件：（简短形式）所有的用户都必须是女 const isAllGirl = users.every(item =&gt; item.sex === 1); // 条件：至少一个用户是男的 const isAnyMan = users.some(item =&gt; item.sex === 2);&#125; 使用正则表达式12345678const imgType =&#x27;jpg&#x27;if(imgType === &#x27;jpg&#x27; || imgType === &#x27;png&#x27; || imgType === &#x27;gif&#x27;)&#123; console.log(&#x27;is image&#x27;)&#125;// 使用match匹配正则表达式if(imgType.match(/.*?(gif|png|jpg)/gi))&#123; console.log(&#x27;is image&#x27;)&#125; 连接字符串1234let name = &#x27;Symbol&#x27;let message = &#x27;Hello,I\\&#x27;m&#x27; + name + &#x27;take care &#x27;// 采用传统加号，看着很冗余,且容易出错// 艾玛，模板字符香，真想let message = `Hello,I&#x27;m $&#123;name&#125; take care `","categories":[{"name":"前端","slug":"前端","permalink":"https://www.i100.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"优雅","slug":"优雅","permalink":"https://www.i100.xyz/tags/%E4%BC%98%E9%9B%85/"}]},{"title":"git常用命令总结","slug":"git常用命令总结","date":"2022-01-07T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/acc3d3b0.html","link":"","permalink":"https://www.i100.xyz/posts/acc3d3b0.html","excerpt":"新建仓库1234567echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:foxscalliom/test.gitgit push -u origin main","text":"新建仓库1234567echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git branch -M maingit remote add origin git@github.com:foxscalliom/test.gitgit push -u origin main 拉取仓库123git remote add origin git@github.com:foxscalliom/test.gitgit branch -M maingit push -u origin main 不保留本地12git reset --hard git pull origin main","categories":[{"name":"Git","slug":"Git","permalink":"https://www.i100.xyz/categories/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"https://www.i100.xyz/tags/github/"}]},{"title":"在centos7安装nodejs并升级nodejs版本","slug":"在centos7安装nodejs并升级nodejs版本","date":"2022-01-06T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/59268fdb.html","link":"","permalink":"https://www.i100.xyz/posts/59268fdb.html","excerpt":"1. 安装 nodejs 1.1 使用 EPEL 安装EPEL（Extra Packages for Enterprise Linux）企业版 Linux 的额外软件包，是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。先确认系统是否已经安装了 epel-release 包： 12$ yum info epel-release","text":"1. 安装 nodejs 1.1 使用 EPEL 安装EPEL（Extra Packages for Enterprise Linux）企业版 Linux 的额外软件包，是 Fedora 小组维护的一个软件仓库项目，为 RHEL/CentOS 提供他们默认不提供的软件包。先确认系统是否已经安装了 epel-release 包： 12$ yum info epel-release 如果有输出有关 epel-release 的已安装信息，则说明已经安装，如果提示没有安装或可安装，则安装 1$ yum install epel-release 安装完后，就可以使用 yum 命令安装 nodejs 了，安装的一般会是 6.x 的版本，并且会将 npm(3.x) 作为依赖包一起安装 1$ sudo yum install nodejs 安装完成后，验证是否正确的安装，node -v，如果输出如下版本信息，说明成功安装 1v6.13.3 问题来了，现在 nodejs 发的版本比较快，有些新的框架需要 node 的新版本，那如何升级。到现在，node 的最新版本是10.4.1，那么，下面介绍如何升级 nodejs 1.2 卸载 nodejs 注意：这里卸载并非必要步骤。只是提供卸载的方案，请按需操作，不要安装后又删除又进行安装掉进死循环了。 1.2.1 使用 yum 先删除一次 1yum remove nodejs npm -y 1.2.2 手动删除残留 进入 /usr/local/lib 删除所有 node 和 node_modules 文件夹 进入 /usr/local/include 删除所有 node 和 node_modules 文件夹 检查 ~ 文件夹里面的 “local” “lib” “include” 文件夹，然后删除里面的所有 “node” 和 “node_modules” 文件夹 可以使用以下命令查找 $ find ~/ -name node $ find ~/ -name node_modules 1.2.3 进入 /usr/local/bin 删除 node 的可执行文件 删除: /usr/local/bin/npm 删除: /usr/local/share/man/man1/node.1 删除: /usr/local/lib/dtrace/node.d 删除: rm -rf /home/[homedir]/.npm 删除: rm -rf /home/root/.npm 2. 升级 nodesj 2.1 安装 nn 是 nodejs 管理工具，是 TJ 写的，Github: https://github.com/tj/n 1$ npm install -g n 2.2 安装 nodejs 版本安装最新版 1$ n latest 安装指定版本 1$ n 8.11.3 2.3 切换 nodejs 版本1$ n 选择已安装的版本 12node/8.11.3node/10.4.1 查看当前版本node -v，下面表示已切换成功 1v8.13.3 但问题来了，切换后，查看版本还是原来的 v6.13.3，看下面 使用 n 切换 nodejs 版本失效的解决办法 3 切换失效的解决办法 3.1 查看 node 当前安装路径12$ which node/usr/local/bin/node #举个例子 3.2 修改默认路径而 n 默认安装路径是 /usr/local，若你的 node 不是在此路径下，n 切换版本就不能把 bin、lib、include、share 复制该路径中，所以我们必须通过 N_PREFIX 变量来修改 n 的默认 node 安装路径。编辑环境配置文件： 1$ vim ~/.bash_profile 3.3 将下面两行代码插入到文件末尾：12export N_PREFIX=/usr/local #node实际安装位置export PATH=$N_PREFIX/bin:$PATH 3.4 :wq保存退出3.5 执行 source 使修改生效。1$ source ~/.bash_profile 3.6 这时候再查看node -v发现版本切换成功了。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2021-12-31T16:00:00.000Z","updated":"2022-01-09T09:28:43.395Z","comments":true,"path":"posts/4a17b156.html","link":"","permalink":"https://www.i100.xyz/posts/4a17b156.html","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"前端","slug":"前端","permalink":"https://www.i100.xyz/categories/%E5%89%8D%E7%AB%AF/"},{"name":"ES6","slug":"ES6","permalink":"https://www.i100.xyz/categories/ES6/"},{"name":"Git","slug":"Git","permalink":"https://www.i100.xyz/categories/Git/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://www.i100.xyz/tags/centos/"},{"name":"nginx","slug":"nginx","permalink":"https://www.i100.xyz/tags/nginx/"},{"name":"优雅","slug":"优雅","permalink":"https://www.i100.xyz/tags/%E4%BC%98%E9%9B%85/"},{"name":"github","slug":"github","permalink":"https://www.i100.xyz/tags/github/"}]}